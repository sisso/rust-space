
// Generated by flapigen. Do not edit.

// This warning occurs, because both Rust and C# have mehtod `ToString()`.
#pragma warning disable CS0114

using System;
using System.Runtime.InteropServices;

namespace ffi_domain_2
{
    internal static class RustString {
        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern void c_string_delete(IntPtr c_char_ptr);

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern /* *mut RustString */ IntPtr c_str_u16_to_string(/* *const u16 */ IntPtr c_string_ptr);

        internal static string rust_to_dotnet(/* *const u16 */ IntPtr c_string_ptr)
        {
            var dotnet_str = Marshal.PtrToStringUni(c_string_ptr);
            RustString.c_string_delete(c_string_ptr);
            return dotnet_str;
        }

        internal static /* *mut RustString */ IntPtr dotnet_to_rust(string dotnet_str)
        {
            var c_string_ptr = Marshal.StringToHGlobalUni(dotnet_str);
            var rust_string_ptr = c_str_u16_to_string(c_string_ptr);
            Marshal.FreeHGlobal(c_string_ptr);
            return rust_string_ptr;
        }
    }

    [System.Serializable]
    public class Error : System.Exception
    {
        public Error(string message) : base(message) { }
    }

    
    public class SectorData: IDisposable {
        internal IntPtr nativePtr;

        internal SectorData(IntPtr nativePtr) {
            this.nativePtr = nativePtr;
        }

        public void Dispose() {
            DoDispose();
            GC.SuppressFinalize(this);
        }

        private void DoDispose() {
            if (nativePtr != IntPtr.Zero) {
                SectorData_delete(nativePtr);
                nativePtr = IntPtr.Zero;
            }
        }

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SectorData_delete(IntPtr __this);

        ~SectorData() {
            DoDispose();
        }

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern /* SectorData */ IntPtr SectorData_new();

        
        public  SectorData () {
            
            this.nativePtr = SectorData_new();
            
            
        }

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern int SectorData_index(/* SectorData */ IntPtr __this);

        
        public  int Index() {
            var __this_0 = this.nativePtr;

            var __ret_0 = SectorData_index(__this_0);
            var __ret_1 = __ret_0;
            return __ret_1;
        }

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern /* Option */ IntPtr SectorData_coords(/* SectorData */ IntPtr __this);

        
        public  Tuple<float, float> Coords() {
            var __this_0 = this.nativePtr;

            var __ret_0 = SectorData_coords(__this_0);
            var __ret_1 = RustTuple2Tfloatfloat.rust_to_dotnet(__ret_0);
            return __ret_1;
        }
} // class

    
    public class SpaceGame: IDisposable {
        internal IntPtr nativePtr;

        internal SpaceGame(IntPtr nativePtr) {
            this.nativePtr = nativePtr;
        }

        public void Dispose() {
            DoDispose();
            GC.SuppressFinalize(this);
        }

        private void DoDispose() {
            if (nativePtr != IntPtr.Zero) {
                SpaceGame_delete(nativePtr);
                nativePtr = IntPtr.Zero;
            }
        }

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SpaceGame_delete(IntPtr __this);

        ~SpaceGame() {
            DoDispose();
        }

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern /* SpaceGame */ IntPtr SpaceGame_new(/* Option */ IntPtr rgs);

        
        public  SpaceGame (System.Collections.Generic.List<string> rgs_0) {
            var rgs_1 = RustVecstring.dotnet_to_rust(rgs_0);
            this.nativePtr = SpaceGame_new(rgs_1);
            
            
        }

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern int SpaceGame_get_sectors_len(/* SpaceGame */ IntPtr __this);

        
        public  int GetSectorsLen() {
            var __this_0 = this.nativePtr;

            var __ret_0 = SpaceGame_get_sectors_len(__this_0);
            var __ret_1 = __ret_0;
            return __ret_1;
        }

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern /* SectorData */ IntPtr SpaceGame_get_sector(/* SpaceGame */ IntPtr __this, int i);

        
        public  SectorData GetSector(int i_0) {
            var __this_0 = this.nativePtr;
var i_1 = i_0;
            var __ret_0 = SpaceGame_get_sector(__this_0, i_1);
            var __ret_1 = new SectorData(__ret_0);
            return __ret_1;
        }
} // class

    internal static class RustTuple2Tfloatfloat {

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern /* Tuple */ IntPtr RustTuple2Tfloatfloat_new(float t_1, float t_2);

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern float RustTuple2Tfloatfloat_take_1(IntPtr tuple);

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern float RustTuple2Tfloatfloat_take_2(IntPtr tuple);

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern void RustTuple2Tfloatfloat_delete(IntPtr tuple);

        internal static Tuple<float, float> rust_to_dotnet(IntPtr rustTuple)
        {
            var t_1_rust = RustTuple2Tfloatfloat_take_1(rustTuple);
            var t_1 = t_1_rust;
            var t_2_rust = RustTuple2Tfloatfloat_take_2(rustTuple);
            var t_2 = t_2_rust;
            var ret = Tuple.Create(t_1, t_2);
            RustTuple2Tfloatfloat_delete(rustTuple);
            return ret;
        }
        internal static /* Tuple */ IntPtr dotnet_to_rust(Tuple<float, float> tuple)
        {
            var t_1 = tuple.Item1;
            var t_1_rust = t_1;
            var t_2 = tuple.Item2;
            var t_2_rust = t_2;
            // We don't call delete in `Input` scenario. Rust-side conversion code will take care of it.
            return RustTuple2Tfloatfloat_new(t_1_rust, t_2_rust);            
        }
    }
    
    public static class RustVecstring {
        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr RustVecstring_new();
        
        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern void RustVecstring_push(IntPtr vecPtr, /* RustString */ IntPtr element);

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern /* Option<i_type> */ IntPtr RustVecstring_iter_next(IntPtr iterPtr);
        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern void RustVecstring_iter_delete(IntPtr iterPtr);

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern /* RustString */ IntPtr RustVecstring_option_take(IntPtr optPtr);

        [DllImport("ffi_domain_2_native", CallingConvention = CallingConvention.Cdecl)]
        internal static extern byte RustVecstring_option_is_some(IntPtr optPtr);


        internal static System.Collections.Generic.List<string> rust_to_dotnet(IntPtr iterPtr) {
            var list = new System.Collections.Generic.List<string>();
            while (true)
            {
                var next_rust_opt = RustVecstring.RustVecstring_iter_next(iterPtr);
                if (RustVecstring_option_is_some(next_rust_opt) == 0)
                {
                    break;
                }
                var value_rust = RustVecstring_option_take(next_rust_opt);
                var value = RustString.rust_to_dotnet(value_rust);
                list.Add(value);
            }
            RustVecstring_iter_delete(iterPtr);
            return list;
        }

        internal static IntPtr dotnet_to_rust(System.Collections.Generic.List<string> list) {
            var vec = RustVecstring_new();
            foreach (var element in list)
            {
                var i_element = RustString.dotnet_to_rust(element);
                RustVecstring.RustVecstring_push(vec, i_element);
            }
            return vec;
        }
    }
        } // namespace
